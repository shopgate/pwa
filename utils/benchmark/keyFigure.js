export const KEY_FIGURE_MODE_ADD = 'add';

// Score is genereated by counting the occurence of each key.
export const KEY_FIGURE_METHOD_COUNT = 'count';
// Score is generated by measuring time between each key was started and stopped.
export const KEY_FIGURE_METHOD_TIME = 'time';
// Score is generated by collecting "performance events" during a start and stop. (chrome only)
export const KEY_FIGURE_METHOD_OBSERVER = 'observer';

/**
 * Class
 */
export default class KeyFigure {
  /**
   * Initializes the keyfigure and set it as started.
   * @param {string} mode Append mode.
   * @param {string} method Method.
   */
  constructor(mode, method) {
    this.mode = mode;
    this.method = method;
    this.setStarted(true);
  }

  /**
   * Toggles the status of the benchmark and also clears the result.
   * @param {bool} started Whether benchmark is running or not.
   */
  setStarted(started) {
    if (started) {
      this.measure = {
        exclusiveTimers: [],
        timings: {},
        observers: {},
        inclusive: {},
        exclusive: {},
      };
    }

    this.started = true;
  }

  /**
   * Starts measuring.
   * @param {string} key Unique identifier for action.
   */
  startMeasure(key) {
    if (!this.started) return;

    // Prepare storage for key if not existing yet.
    if (typeof this.measure.inclusive[key] === 'undefined') {
      this.measure.inclusive[key] = this.method !== KEY_FIGURE_METHOD_OBSERVER ? 0 : {};
      this.measure.exclusive[key] = this.method !== KEY_FIGURE_METHOD_OBSERVER ? 0 : {};
    }

    // Push the current start time into an array (allows to collect the action multiple times)
    if (this.method === KEY_FIGURE_METHOD_TIME) {
      this.measure.timings[key] = this.measure.timings[key] || [];
      this.measure.timings[key].push({
        start: performance.now(),
        stop: null,
        others: {},
      });
    }

    // Push the performance observer instance and start watching for events.
    if (this.method === KEY_FIGURE_METHOD_OBSERVER) {
      // Create observer and start observing.
      const observer = {
        instance: new PerformanceObserver(event => observer.stored.push(...event.getEntries())),
        events: [],
        stored: [],
      };
      observer.instance.observe({
        entryTypes: ['measure', 'paint', 'navigation', 'resource'],
      });

      this.measure.observers[key] = this.measure.observers[key] || [];
      this.measure.observers[key].push(observer);
    }
  }

  /**
   * Stops measuring.
   * @param {string} key Unique key.
   */
  stopMeasure(key) {
    if (!this.started) return;

    // For counting mode just increment the call count.
    if (this.method === KEY_FIGURE_METHOD_COUNT) {
      this.measure.inclusive[key] += 1;
      this.measure.exclusive[key] += 1;
    }

    // Evaluate performance events.
    if (this.method === KEY_FIGURE_METHOD_OBSERVER) {
      /*
       * Collect all events from the observer.
       *
       * NOTE: Chrome behaves different in certain cases:
       *       - The `takeRecords` function won't return any data but
       *         the event callback is called for each event.
       *       - The event callback is not executed at all but `takeRecords`
       *         will return all events.
       */
      const { instance, stored } = this.measure.observers[key].pop();
      const records = instance.takeRecords();
      const events = records.length === 0 ? stored : records;

      instance.disconnect(); // Stops observing, free memory etc.

      // We have to parse the event name to figure out what kind of action it was.
      const renders = events
        .filter(event => event.entryType === 'measure')
        .filter(event => event.name.endsWith('[update]'))
        .map(event => ({
          duration: event.duration,
          componentName: event.name.replace('⚛', '').replace(/ /g, '').replace('[update]', ''),
        }));
      const mounts = events
        .filter(event => event.entryType === 'measure')
        .filter(event => event.name.endsWith('.componentDidMount'))
        .map(event => ({
          duration: event.duration,
          componentName: event.name.replace('⚛', '').replace(/ /g, '').replace('.componentDidMount', ''),
        }));

      // Process renders that happened for each component during the benchmark.
      renders.forEach(({ componentName, duration }) => {
        // For the first time component rendered we need to start at 1.
        this.measure.inclusive[key][componentName] = this.measure.inclusive[key][componentName] || {
          render: 0,
          renderTime: 0,
          mount: 0,
          mountTime: 0,
        };

        // Increment total renders by 1.
        const comp = this.measure.inclusive[key][componentName];
        comp.render += 1;
        comp.renderTime += duration;
      });

      // Process mounts
      mounts.forEach(({ componentName, duration }) => {
        // For the first time component mounted we need to start at 1.
        this.measure.inclusive[key][componentName] = this.measure.inclusive[key][componentName] || {
          render: 0,
          renderTime: 0,
          mount: 0,
          mountTime: 0,
        };

        // Increment total mounts by 1.
        const comp = this.measure.inclusive[key][componentName];
        comp.mount += 1;
        comp.mountTime += duration;
      });
    }

    // For timing mode we diff start with end time and summarize the timing.
    if (this.method === KEY_FIGURE_METHOD_TIME) {
      // Add inclusive timer.
      const timing = this.measure.timings[key].pop();
      const time = performance.now() - timing.start;

      // Add exclusive timer.
      this.measure.exclusiveTimers.push({ key, time });

      // Calculate measure.
      const currentMeasure = {
        inclusive: time,
        exclusive: time,
      };

      /**
       * Calculates exclusive timings by removing other executions that
       * were running at the same time.
       * https://stackoverflow.com/a/17902682
       */
      if (this.measure.exclusiveTimers.length >= 2) {
        const [first, ...remaining] = this.measure.exclusiveTimers;
        this.measure.exclusiveTimers = remaining;
        currentMeasure.exclusive -= first.time;

        // Reset if callstack reached last call.
        if (this.measure.exclusiveTimers.length === 1) {
          this.measure.exclusiveTimers = [];
        }
      }

      this.measure.inclusive[key] += currentMeasure.inclusive;
      this.measure.exclusive[key] += currentMeasure.exclusive;
    }
  }
}
